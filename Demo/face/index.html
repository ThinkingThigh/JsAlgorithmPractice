<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>æ¶²æ™¶å±æ¨¡æ‹Ÿ</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      background: #222;
      overflow: hidden;
    }
    .lcd-container {
      display: grid;
      width: 100vw;
      height: 100vh;
      gap: 2px;
      margin: 0;
      padding: 0;
      border-radius: 0;
      background: #222;
      position: relative;
    }
    .pixel {
      width: 100%;
      height: 100%;
      background: #444;
      border-radius: 3px;
      transition: background 0.2s;
      aspect-ratio: 1 / 1;
    }
    .pixel.on {
      background: #0f0; /* ç‚¹äº®çš„åƒç´ ä¸ºç»¿è‰² */
    }
    .symbol {
      position: absolute;
      top: 16px;
      right: 32px;
      font-size: 3vw;
      color: #fff;
      z-index: 10;
      pointer-events: none;
      user-select: none;
      text-shadow: 2px 2px 8px #000;
    }
    .face-selector {
      position: fixed;
      right: 32px;
      bottom: 32px;
      z-index: 20;
      background: rgba(34,34,34,0.95);
      border-radius: 16px;
      box-shadow: 0 2px 12px #0008;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 1.1em;
      width: 56px;
      height: 56px;
      overflow: hidden;
      transition: width 0.25s, height 0.25s, padding 0.25s;
      cursor: pointer;
      align-items: center;
      justify-content: center;
    }
    .face-selector.expanded {
      width: 220px;
      height: 520px;
      padding: 16px 20px 16px 16px;
      overflow-y: auto;
      cursor: default;
      align-items: flex-start;
      justify-content: flex-start;
    }
    .face-selector label {
      color: #fff;
      cursor: pointer;
      margin-bottom: 2px;
      transition: color 0.2s;
      display: none;
    }
    .face-selector.expanded label {
      display: block;
    }
    .face-selector label.selected {
      color: #0f0;
      font-weight: bold;
    }
    .face-selector input[type="radio"] {
      margin-right: 6px;
    }
    .face-selector .face-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: #111;
      color: #0f0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2em;
      border: 2px solid #0f0;
      margin: 4px auto 0 auto;
      box-shadow: 0 2px 8px #0006;
      transition: background 0.2s, color 0.2s;
      pointer-events: none;
      user-select: none;
    }
    .face-selector.expanded .face-btn {
      display: none;
    }
  </style>
</head>
<body>
  <div class="lcd-container" id="lcd"></div>
  <div class="face-selector" id="faceSelector">
    <div class="face-btn" id="faceBtn">ğŸ˜Š</div>
  </div>
  <script>
    // åªä¿ç•™å››ä¸ªç²¾ç»†è¡¨æƒ…
    const faces = [
      { name: 'å–œ', symbol: '!', key: 'happy' },
      { name: 'æ€’', symbol: '!', key: 'angry' },
      { name: 'å“€', symbol: '.', key: 'sad' },
      { name: 'ä¹', symbol: '?', key: 'amused' },
    ];
    let currentFace = 0;
    // æ¸²æŸ“è¡¨æƒ…é€‰æ‹©å™¨
    function renderFaceSelector() {
      const selector = document.getElementById('faceSelector');
      // åªæ˜¾ç¤ºå½“å‰è¡¨æƒ…çš„æŒ‰é’®
      selector.innerHTML = `<div class="face-btn" id="faceBtn">${faces[currentFace].symbol||'ğŸ˜Š'}</div>` +
        faces.map((f, i) =>
          `<label class="${i===currentFace?'selected':''}"><input type="radio" name="face" value="${i}" ${i===currentFace?'checked':''}>${f.name}</label>`
        ).join('');
      selector.querySelectorAll('input[type=radio]').forEach(input => {
        input.addEventListener('change', e => {
          currentFace = parseInt(e.target.value);
          renderFaceSelector();
          createLcdGrid();
        });
      });
      // æ‚¬åœå±•å¼€
      selector.onmouseenter = () => selector.classList.add('expanded');
      selector.onmouseleave = () => selector.classList.remove('expanded');
    }
    // å­—ç¬¦åƒç´ å­—æ¨¡ï¼ˆä»…æ”¯æŒå¸¸ç”¨ç¬¦å·å’Œæ•°å­—/å­—æ¯ï¼Œå¯æ‰©å±•ï¼‰
    const charMap = {
      '!': [
        '1',
        '1',
        '1',
        '1',
        '1',
        '0',
        '1',
      ],
      '?': [
        '111',
        '001',
        '011',
        '010',
        '000',
        '010',
      ],
      '.': [
        '0',
        '0',
        '0',
        '0',
        '1',
      ],
      '-': [
        '000',
        '111',
        '000',
      ],
      ',': [
        '0',
        '0',
        '1',
        '1',
      ],
      ':': [
        '0',
        '1',
        '0',
        '1',
        '0',
      ],
      // å¯æ‰©å±•æ›´å¤šç¬¦å·
    };
    // åœ¨åƒç´ å±å³ä¸Šè§’ç»˜åˆ¶ç¬¦å·
    function drawSymbolOnLcd(rows, cols, symbol) {
      if(!symbol) return [];
      let pixels = [];
      let offsetX = cols - 8; // å³ä¾§ç•™8æ ¼
      let offsetY = 2; // é¡¶éƒ¨ç•™2æ ¼
      let curX = offsetX;
      for(const ch of symbol) {
        const map = charMap[ch] || [];
        for(let y=0; y<map.length; y++) {
          for(let x=0; x<map[y].length; x++) {
            if(map[y][x]==='1') {
              pixels.push((offsetY+y)*cols + (curX+x));
            }
          }
        }
        curX += 4; // å­—ç¬¦é—´éš”
      }
      return pixels;
    }
    // åŠ¨æ€è¡¨æƒ…æ¸²æŸ“
    function createLcdGrid() {
      const lcd = document.getElementById('lcd');
      lcd.innerHTML = '<div class="symbol" id="symbol"></div>';
      // è®¡ç®—æ¯ä¸ªåƒç´ çš„æœ€å°å°ºå¯¸å’Œé—´è·
      const minPixelSize = 20;
      const gap = 2;
      const screenW = window.innerWidth;
      const screenH = window.innerHeight;
      const cols = Math.floor((screenW + gap) / (minPixelSize + gap));
      const rows = Math.floor((screenH + gap) / (minPixelSize + gap));
      lcd.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      lcd.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      for(let i=0; i<rows*cols; i++) {
        const pixel = document.createElement('div');
        pixel.className = 'pixel';
        lcd.appendChild(pixel);
      }
      // å¯åŠ¨åŠ¨ç”»
      startFaceAnimation(rows, cols, faces[currentFace].key);
    }
    function lightUpPixels(indices) {
      const pixels = document.querySelectorAll('.pixel');
      indices.forEach(idx => {
        if(pixels[idx]) pixels[idx].classList.add('on');
      });
    }
    function clearPixels() {
      const pixels = document.querySelectorAll('.pixel');
      pixels.forEach(pixel => pixel.classList.remove('on'));
    }
    // åŠ¨ç”»ä¸»æ§
    let faceFrame = 0;
    let faceTimer = null;
    function startFaceAnimation(rows, cols, faceKey) {
      if(faceTimer) clearInterval(faceTimer);
      function animate() {
        clearPixels();
        drawFace(rows, cols, faceKey, faceFrame);
        faceFrame = (faceFrame + 1) % 120;
      }
      animate();
      faceTimer = setInterval(animate, 120);
    }
    // å‚è€ƒBç«™å°ç”µè§†é£æ ¼ä¼˜åŒ–å››è¡¨æƒ…
    function drawFace(rows, cols, faceKey, frame) {
      const cx = Math.floor(cols / 2);
      const cy = Math.floor(rows / 2);
      const eyeOffsetX = Math.floor(cols * 0.19);
      const eyeOffsetY = Math.floor(rows * 0.18);
      const eyeW = Math.max(4, Math.floor(cols * 0.08));
      const eyeH = Math.max(3, Math.floor(rows * 0.07));
      const mouthW = Math.floor(cols * 0.18);
      const mouthY = cy + Math.floor(rows * 0.13);
      let pixels = [];
      // çœ¨çœ¼åŠ¨ç”»
      const isBlink = frame % 60 < 6;
      if(faceKey === 'happy') {
        // å–œï¼šå¤§åœ†çœ¯çœ¼+å¤§Uå‹å˜´
        for(let i=0;i<2;i++) {
          const sign = i===0?-1:1;
          if(isBlink) {
            // çœ¨çœ¼ï¼šç»†çº¿
            for(let x=-eyeW;x<=eyeW;x++) {
              const px = cx + sign*eyeOffsetX + x;
              const py = cy - eyeOffsetY;
              pixels.push(py*cols + px);
            }
          } else {
            // å¤§åœ†çœ¼+é«˜å…‰
            for(let y=-eyeH;y<=eyeH;y++) {
              for(let x=-eyeW;x<=eyeW;x++) {
                if(x*x/(eyeW*eyeW)+y*y/(eyeH*eyeH)<=1) {
                  const px = cx + sign*eyeOffsetX + x;
                  const py = cy - eyeOffsetY + y;
                  pixels.push(py*cols + px);
                  // é«˜å…‰ç‚¹
                  if(x === -eyeW+2 && y === -eyeH+2) {
                    pixels.push((py-1)*cols + (px-1));
                  }
                }
              }
            }
          }
        }
        // å¤§Uå‹å˜´
        for(let t=-mouthW;t<=mouthW;t++) {
          const x = cx + t;
          const y = mouthY + Math.floor(2.2 * Math.pow(t/mouthW,2) * eyeH + 2);
          pixels.push(y*cols + x);
          pixels.push((y+1)*cols + x);
        }
        pixels = pixels.concat(drawSymbolOnLcd(rows, cols, '!'));
      } else if(faceKey === 'angry') {
        // æ€’ï¼šç²—çœ‰+å¤§åœ†çœ¼+å€’Vå˜´
        // ç²—çœ‰
        for(let i=0;i<2;i++) {
          const sign = i===0?-1:1;
          for(let t=-eyeW-2;t<=eyeW+2;t++) {
            const x = cx + sign*eyeOffsetX + t;
            const y = cy - eyeOffsetY - eyeH - 2 - Math.floor(t/(eyeW+2)*eyeH*0.7);
            pixels.push(y*cols + x);
            pixels.push((y+1)*cols + x);
          }
        }
        // å¤§åœ†æ€’çœ¼
        for(let i=0;i<2;i++) {
          const sign = i===0?-1:1;
          if(isBlink) {
            for(let x=-eyeW;x<=eyeW;x++) {
              const px = cx + sign*eyeOffsetX + x;
              const py = cy - eyeOffsetY;
              pixels.push(py*cols + px);
            }
          } else {
            for(let y=-eyeH;y<=eyeH;y++) {
              for(let x=-eyeW;x<=eyeW;x++) {
                if(x*x/(eyeW*eyeW)+y*y/(eyeH*eyeH)<=1) {
                  const px = cx + sign*eyeOffsetX + x;
                  const py = cy - eyeOffsetY + y;
                  pixels.push(py*cols + px);
                  // é«˜å…‰ç‚¹
                  if(x === -eyeW+2 && y === -eyeH+2) {
                    pixels.push((py-1)*cols + (px-1));
                  }
                }
              }
            }
          }
        }
        // å€’Vå‹å˜´
        for(let t=-mouthW;t<=mouthW;t++) {
          const x = cx + t;
          const y = mouthY + Math.floor(-Math.abs(t/mouthW)*eyeH + 2);
          pixels.push(y*cols + x);
          pixels.push((y+1)*cols + x);
        }
        pixels = pixels.concat(drawSymbolOnLcd(rows, cols, '!'));
      } else if(faceKey === 'sad') {
        // å“€ï¼šå¤§åœ†ä¸‹å‚çœ¼+æ³ªç +ä¸‹å¼¯å˜´
        for(let i=0;i<2;i++) {
          const sign = i===0?-1:1;
          if(isBlink) {
            for(let x=-eyeW;x<=eyeW;x++) {
              const px = cx + sign*eyeOffsetX + x;
              const py = cy - eyeOffsetY;
              pixels.push(py*cols + px);
            }
          } else {
            for(let y=-eyeH;y<=eyeH;y++) {
              for(let x=-eyeW;x<=eyeW;x++) {
                if(x*x/(eyeW*eyeW)+y*y/(eyeH*eyeH)<=1) {
                  const px = cx + sign*eyeOffsetX + x;
                  const py = cy - eyeOffsetY + y + Math.floor(Math.abs(x/eyeW)*2); // ä¸‹å‚
                  pixels.push(py*cols + px);
                  // é«˜å…‰ç‚¹
                  if(x === -eyeW+2 && y === -eyeH+2) {
                    pixels.push((py-1)*cols + (px-1));
                  }
                }
              }
            }
            // åŠ¨æ€æ³ªç 
            if(frame%40<20) {
              for(let drop=0;drop<2;drop++) {
                pixels.push((cy-eyeOffsetY+eyeH+4+drop+frame%3)*cols + (cx+sign*eyeOffsetX));
              }
            }
          }
        }
        // ä¸‹å¼¯å˜´
        for(let t=-mouthW;t<=mouthW;t++) {
          const x = cx + t;
          const y = mouthY + Math.floor(-1.5 * Math.pow(t/mouthW,2) * eyeH + 2);
          pixels.push(y*cols + x);
          pixels.push((y+1)*cols + x);
        }
        pixels = pixels.concat(drawSymbolOnLcd(rows, cols, '.'));
      } else if(faceKey === 'amused') {
        // ä¹ï¼šå¤§åœ†çœ¼+å¤§Uå‹å˜´
        for(let i=0;i<2;i++) {
          const sign = i===0?-1:1;
          if(isBlink) {
            for(let x=-eyeW;x<=eyeW;x++) {
              const px = cx + sign*eyeOffsetX + x;
              const py = cy - eyeOffsetY;
              pixels.push(py*cols + px);
            }
          } else {
            for(let y=-eyeH-1;y<=eyeH+1;y++) {
              for(let x=-eyeW-1;x<=eyeW+1;x++) {
                if(x*x/(eyeW*eyeW)+y*y/(eyeH*eyeH)<=1) {
                  const px = cx + sign*eyeOffsetX + x;
                  const py = cy - eyeOffsetY + y;
                  pixels.push(py*cols + px);
                  // é«˜å…‰ç‚¹
                  if(x === -eyeW+2 && y === -eyeH+2) {
                    pixels.push((py-1)*cols + (px-1));
                  }
                }
              }
            }
          }
        }
        // å¤§Uå‹å˜´
        for(let t=-mouthW;t<=mouthW;t++) {
          const x = cx + t;
          const y = mouthY + Math.floor(2.2 * Math.pow(t/mouthW,2) * eyeH + 2);
          pixels.push(y*cols + x);
          pixels.push((y+1)*cols + x);
        }
        pixels = pixels.concat(drawSymbolOnLcd(rows, cols, '?'));
      }
      lightUpPixels(pixels);
    }
    window.addEventListener('resize', createLcdGrid);
    renderFaceSelector();
    createLcdGrid();
  </script>
</body>
</html>
